# 基于比较的性能最优排序：归并排序，堆排序，快速排序

### 堆
数据类型：数组
逻辑结构：完全二叉树
一个黑盒 要求右 add&popMax

### 完全二叉树
从左到右依次满的二叉树
         0
      1     2
     3  4  5  6
    7 8
i
左 2*i+1
右 2*i+2
父 i-1/2
高度 log N

### 大根堆
任何一颗子树中根是最大值

i 与 i-1/2 比较，如果比后者大就交换                                    => heapInsert  add     O(logN)
砍掉根，最后一个数放到根，然后从根开始，跟自己较大的孩子PK，如果比不过进行交换  => heapify    popMax   O(logN)

扩容时add操作时间复杂度变为O(N)，然而均摊时间复杂度仍然为O(logN)

## 堆排序
1. 数组转为大根堆
2. 根元素与最低元素做交换，有效区长度减一，直到有效区长度为0

给一个个数字，构造成大根堆    时间复杂度为O(N*logN)
依次给全所有数，构造成大根堆   时间复杂度为O(N)
额外空间复杂度：O(1)
系统提供的优先级队列为大根堆

练习题：
已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元 素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的 排序算法针对这个数据进行排序。
=>构造一个长度为k+1的小根堆，然后把数组前k+1个数放进去，然后弹出根元素并将数组中剩下的元素放进去