# 宽度优先遍历
1. 队列不为空，弹出就打印
2. 先进左再进右

# 求二叉树的最大宽度
hashMap 记录层

# 二叉树的递归套路
以任意一个节点为头答案是什么
or
利用子树的信息构建可能性

1. 如何判断一棵二叉树是否是搜索二叉树？（父 > 左子 & 父 < 右子）
方法一：中序遍历从小到大
方法二：
以x为头的树搜索二叉树
条件一：左子树整体是搜索二叉树
条件二：右子树整体是搜索二叉树
条件三：左子树max < x < 右子树min

递归规则：
整棵树是搜索二叉树
整棵树的最小值
整棵树的最大值

2. 如何判断一棵树是满二叉树？
N = 2^h - 1【N：节点个数，h：二叉树最大高度】
2 ^ h => 1 << h ?

3. 如何判断一棵树是平衡二叉树？
左右子树高度差值小于2

4. 给定两个二叉树节点node1和node2，找到它们的最低公共祖先
可能性一：x上无o1也无o2，x整棵树不存在低共
可能性二：x上o1o2只有一个，x整棵树不存在低共
可能性三：x上有o1o2，都在左树 or 都在右树 or 一个在左一个在右

递归规则：
有没有发现o1
有没有发现o2
有没有低共

5. 如何判断一棵树是完全二叉树？
宽度优先遍历，满足三个条件
条件一：遍历的任何节点不能有右无左
条件二：一旦遇到孩子不双全的节点，后续遇到的节点必须是叶节点（没有左子右子）

时间复杂度：O(N)

树形DP -> 二叉树的递归套路

