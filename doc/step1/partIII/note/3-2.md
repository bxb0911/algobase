# 链表
## 链表表示
1. 单链表
class Node<V> {
  V value;
  Node next;
}
2. 双向链表
class Node<V> {
  V value;
  Node next;
  Node last;
}

## 基础练习题
分别实现反转单向链表和反转双向链表的函数
要求：若链表长度为N，时间复杂度要求为O(N)，额外空间复杂度要求为O(1)

## 链表问题在笔试面试中的方法论
1. 笔试，不用太在乎空间复杂度，一切为了时间复杂度
2. 面试，时间复杂度放在第一位，但是一定要找到空间最省的方法

练习题：
1. 一个链表是否为回文结构
笔试：放到栈里面，然后弹出与原来的链表左比对，能对上就是回文结构
面试：快慢指针法【注意节点个数及边界条件】
I: S指针依次走一步，F指针一次走两步，直到S指针越界
II: 将S到最后的部分进行链表反转
III：两头各一个指针，每次均走一步，比对下是否所有节点都相同
IV：S到最后部分反转回来

2. 单链表划分为左边小于划分值，中间等于划分值，右边大于划分值
笔试：节点放到数组进行partition
面试：【注意某一部分不存在的情况及边界条件】
I. 申请6个指针，分别指向各部分的头和尾
小于划分值 -> 小于划分值的头结点(SH)及尾结点(ST)
等于划分值 -> 等于划分值的头结点(EH)及尾结点(ET)
大于划分值 -> 大于划分值的头结点(BH)及尾结点(BT)、
II. 按照以下原则依次连接三部分
SH -> ST -> EH -> ET -> BH -> BT

3. 复制含有随机指针节点的链表
class Node {
  int value;
  Node next;
  Node rand;
  Node(int val) {
    value = val
  }
}
要求：时间复杂度为O(N)，额外空间复杂度为O(1)

笔试：hashmap
I. key->老链表地址  value->新链表地址
II. 通过原链表连接规则给新链表进行next及random连接
面试：
1. 每一个节点之间放入前一个节点的克隆节点
2. 遍历链表，找到每个节点的随机指针，然后随机指针的下一个就是该克隆节点的指向
3. 讲新老链表分出来

面试答题思路：
先说笔试中的解法，然后说优化思路及解法
I. 每个指针指向复制节点
II. 每个克隆节点的random指针，通过上一个节点的next找到random节点，然后取该节点的下一个
III. 将新链表从老链表中剥离