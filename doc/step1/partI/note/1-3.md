# 三种O(N^2)时间复杂的的排序算法
选择排序：
i~N-1找到最小值的位置，与i位置的元素交换(i从0开始)
如：
  [5, 4, 3, 2, 1, 0]
->[0, 5, 4, 3, 2, 1]  // 0~5
->[0, 1, 4, 3, 2, 5]  // 1~5
->[0, 1, 2, 3, 4, 5]  // 2~5
->[0, 1, 2, 3, 4, 5]  // 3~5
->[0, 1, 2, 3, 4, 5]  // 4~5
->[0, 1, 2, 3, 4, 5]  // 5~5

时间复杂度：O(N^2)
额外空间复杂度：O(1)

冒泡排序:
0~N-i与邻近元素作比较，谁大谁去后面(i从1开始)
如：
  [3, 4, 5, 5, 2, 1]
->[3, 4]              // 0~1
->[3, 4, 5]           // 1~2
->[3, 4, 5, 5]        // 2~3
->[3, 4, 5, 2, 5]     // 3~4
->[3, 4, 5, 2, 1, 5]  // 4~5
->[3, 4]              // 0~1
->[3, 4, 5]           // 1~2
->[3, 4, 2, 5]        // 2~3
->[3, 4, 2, 1, 5]     // 3~4
->[3, 4]              // 0~1
->[3, 2, 4]           // 1~2
->[3, 2, 1, 4]        // 2~3
->[2, 3]              // 0~1
->[2, 1, 3]           // 1~2      
->[1, 2]              // 0~1

时间复杂度：O(N^2)
额外空间复杂度：O(1)

插入排序：
0~0,0~1,...,0~i 范围内最后一个元素开始依次向前看，谁小谁去前面
如：
  [4, 3, 1, 2, 5, 0]
->[4]                 // 0~0
->[3, 4]              // 0~1
->[1, 3, 4]           // 0~2
->[1, 2, 3, 4]        // 0~3
->[1, 2, 3, 4, 5]     // 0~4
->[0, 1, 2, 3, 4, 5]  // 0~5

与数据状况有关
时间复杂度：O(N) ~ **O(N^2)**
额外空间复杂度：O(1)


