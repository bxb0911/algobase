# 基于比较的性能最优排序：归并排序，堆排序，快速排序

### 数字分为两块，左边放<=划分值的数，右边放>划分值得数
1. 当前值 <= 区分值，当前值与<=区下一个交换，<=区向右扩一个位置，当前数跳下一个
2. 当前值 > 区分值，<=区不动，当前值跳下一个
<=) 3 7 6 2 0 5 3 4 (>  4
<= 3) 7 6 2 0 5 3 4 (> 
<= 3 2) 6 7 0 5 3 4 (> 
<= 3 2 0) 7 6 5 3 4 (> 
<= 3 2 0 3) 6 5 7 4 (> 
<= 3 2 0 3 4) 5 7 6 (> 

### 荷兰国旗问题（左中右依次为< = >区域）
1. 当前值 < 划分值：当前值与<区下一个交换，<区右扩，当前值跳下一个
2. 当前值 = 划分值：当前值跳下一个
3. 当前值 > 划分值：当前值与>区前一个交换，>区左扩，当前值不动
=区域与>区相撞停止

<) 2 4 4 6 1 7 8 4 2 (>   4
< 2) 4 4 6 1 7 8 4 2 (>
< 2) 4 4 2 1 7 8 4 (6 >
< 2 2 1) 4 4 4 (8 7 6 >

以上两种划分值方式统称为partition

## 快速排序
### 1.0版本
拿最后一个值做划分值
1. <=p | >p | p
2. p与>p第一个元素交换
3. <=p >p 区域递归做1 2步

### 2.0版本
拿最后一个值做划分值
1. <p | >p | p
2. p与>p第一个元素交换
3. <p >p 区域递归做1 2步 （去掉1.0=部分重复partition）

分析：
当全部数字均小于划分值时时间复杂度为O(N^2)
若大于小于划分值规模差不多时时间复杂度为O(N*logN)
-------------以上两种时间复杂度为O(N^2)-------------

### 3.0版本
随机选一个数作为划分值，这样数字规模变为随机好随机差，最后计算出的期望收敛为O(N*logN)

时间复杂度：O(N*logN)
额外空间复杂度：O(logN)~O(N) => O(logN)
