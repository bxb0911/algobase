# 找后继节点
class Node {
  int value;
  Node left;
  Node right
  Node parent;
  Node(int val) {
    value = val;
  }
}

情况一：x有右树，x的后继节点就是x右树最左的节点
情况二：x无右树，往上找父节点，如果该父节点的前一个是该父节点的左子的时候，x的后继就是该父节点

# 找前驱节点
同理

# 二叉树的先序方式序列化和反序列化
序列化：内存结构转为字符串
反序列化：字符串变回内存结构
注意：节点为空必须表示出来

应用：
问题：T2的结构是否跟T1的子树结构相同
解法：T1序列化T2序列化，字符串若有重叠就是包含结构相同的子树

# 折纸问题
一张纸对折N次，返回有几个凹折痕凸折痕
第一次对折：1凹
第二次对折：2凹 2凸
第三次对折：3凹 3凸 3凹 3凸（2折痕上出现凹折痕，下出现凸折痕）
                1凹
            2凹      2凸
          3凹  3凸 3凹   3凸
中序遍历：3凹 2凹 3凸 1凹 3凹 2凸 3凸
