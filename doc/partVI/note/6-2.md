# 贪心算法
给一个问题的解法先后排个序，最好的解法排到最前面，最差的解法排到最后面

局部最优解不一定是整体最优解
但是一般遇到的问题都是局部最优解也是整体最优解的情况

问题1：会议室一个，怎样安排的会议数量最多
a. 会议开始最早的先安排 x
b. 会议持续时间最短的先安排 x
c. 会议结束最早的先安排 ✅

重要：局部最优解是否是全局最优解？
证明很难
直接写计数器用全排列验证与自己的局部最优解是否一致

问题2：给一堆字符串，按照某一种顺序拼接起来字典序最低
字符串长度相同，按位比较
字符串长度不同，短的末尾补0，再按位比较
a. str1，str2 谁字典序低，谁排前 x
b. str1.str2 <= str2.str1 str1在前否则str2在前 ✅
证明：
I.首先证明比较策略是具有传递性的
条件1：a.b <= b.a
条件2：b.c <= c.b
能否证明： a.c <= c.a
拼接 =>
str1.str2 -> str1 * k^str2长度 + str2 (k进制)
m(str) -> k ^ str长度
=> str1 * m(str2) + str2
条件1 => a*m(b)+b <= b*m(a)+a
条件2 => b*m(c)+c <= c*m(b)+b
结论 => a*m(c) + c <= c*m(a) + a
条件1两边-b*c => a*m(b)*c <= b*m(a)*c + a*c - b*c
条件2两边-b*a => b*m(c)*a + c*a - b*a <= c*m(b)*a
=> b*m(c)*a + c*a - b*a <= c*m(b)*a <= b*m(a)*c + a*c - b*c
=> m(c)*a - a <= m(a)*c - c
=> a*m(c) + c <= c*m(a) + a
=> a.c <= c.a
II. 任意交换2,3,...,n,n+1字符，字典序越来越大 -> 数学归纳法

问题3：有一个大金条长度为数组所有数字之和，把所有数切出来，每次切需要花费当前金条的金额，怎样切总代价最低
解答：数组所有数字进小根堆，然后每次弹两个数出来，合并完之后再进入小根堆
如：[6, 3, 2, 9, 13]
小根堆 =>   [2 3 6 9 13]
弹出2 3 =>   5
          2   3
将5扔进小根堆
弹出5 6 =>   11
          5    6
        2   3
将11扔进小根堆
弹出9 11 =>  20
          11   9
        5    6
      2   3
将20扔进小根堆
弹出20 13 =>  33
          20   13
        11  9
       5  6
      2 3
证明：哈弗曼编码问题

问题4：花费-利润问题（RPG游戏）
3-5 7-1 1-7 6-9 100-400
k=3为能做的项目数
w=2为初始本金
项目只能串行不能并行做
最后获得的最大钱数是多少?
解答：
小根堆（花费）：被锁住的项目
1-7
3-5
6-9
7-1
100-400
大根堆（利润）：解锁的项目
第一次：1-7    =>    w=2+7=9

第二次：6-9 3-5 7-1 => w=9+9=18

第三次：3-5 7-1 => w=18+5=23

此时k=3结束，最大钱数是23
